// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3173.IgKnighters2018.subsystems;

import java.sql.Time;

import org.usfirst.frc3173.IgKnighters2018.Robot;
import org.usfirst.frc3173.IgKnighters2018.RobotMap;
import org.usfirst.frc3173.IgKnighters2018.commands.*;
import org.usfirst.frc3173.IgKnighters2018.utilities.Constants;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 * @Bowen
 */
public class Acquisition extends Subsystem {
	
	public static enum AcquisitionIntakeStates {
		OFF, REVERSE, INTAKE
	};
	
	public static enum AcquisitionPivotStates {
		RESET, DEFAULT, CLIMB
	};
	
	private AcquisitionIntakeStates intakeState;
	private AcquisitionPivotStates pivotState;
	
    private final WPI_TalonSRX acquisitionLeft =  RobotMap.acquisitionLeft;
    private final WPI_TalonSRX acquisitionRight = RobotMap.acquisitionRight;
    private final WPI_TalonSRX acquisitionPivot = RobotMap.acquisitionPivot;
    private final Solenoid acquisitionSolenoid = RobotMap.acquisitionSolenoid;
    private final AnalogInput acquisitionRangeSensor = RobotMap.acquisitionRangeSensor;
    
    private Joystick operatorGamepad;
    private boolean isManuallyOperated;
    private boolean acqOpen;
    private float desiredPosition;

    public Acquisition() {
    	acquisitionLeft.configOpenloopRamp(Constants.ACQUISITION_DEFAULT_INTAKE_RAMP_TIME, 0);
    	acquisitionRight.configOpenloopRamp(Constants.ACQUISITION_DEFAULT_INTAKE_RAMP_TIME, 0);
    	
    	acquisitionPivot.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 0);
    	acquisitionPivot.setSensorPhase(false);

    	acquisitionPivot.configOpenloopRamp(0.5f, 0);
    	acquisitionPivot.config_kF(0, Constants.ACQUISITION_F_VALUE, 0);
    	acquisitionPivot.config_kP(0, Constants.ACQUISITION_P_VALUE, 0);
    	acquisitionPivot.config_kI(0, Constants.ACQUISITION_I_VALUE, 0);
    	acquisitionPivot.config_kD(0,  Constants.ACQUISITION_D_VALUE, 0);
    	
    	intakeState = AcquisitionIntakeStates.OFF;
    	pivotState = AcquisitionPivotStates.RESET;
    	isManuallyOperated = true;
    	acqOpen = false;
    	desiredPosition = 0;
    }
    
    @Override
    public void initDefaultCommand() {
    	
    }

    @Override
    public void periodic() {
    	//mid 140, top 413
    	operatorGamepad = Robot.oi.operatorGamepad;
    	//System.out.println(RobotMap.acquisitionRangeSensor.getValue());
    	//SmartDashboard.putNumber("[Acquisition] Pivot Sensor Position", acquisitionPivot.getSelectedSensorPosition(0));
    	//SmartDashboard.putNumber("[Acquisition] Pivot Percent Get", acquisitionPivot.get());
    	//SmartDashboard.putBoolean("Forward Limit Switch (Acquisition)", acquisitionPivot.getSensorCollection().isFwdLimitSwitchClosed());
    	//SmartDashboard.putBoolean("Reverse Limit Switch (Acquisition)", acquisitionPivot.getSensorCollection().isRevLimitSwitchClosed());
    	//SmartDashboard.putNumber("[Acquisition] Desired Sensor Position", desiredPosition);
    	
    	/*if (!acquisitionPivot.getSensorCollection().isFwdLimitSwitchClosed()) {
    		//acquisitionPivot.setSelectedSensorPosition(0, 0, 0);
    		desiredPosition = Constants.ACQUISITION_PIVOT_RESET_POS;
    		//isManuallyOperated = false;
    	}*/
        
    	//System.out.println("I'm running in auto with: " + intakeState.toString());
        switch(intakeState) {
        case OFF:
        	acquisitionLeft.set(0);
        	acquisitionRight.set(0);
        	break;
        case INTAKE:
        	if (RobotMap.acquisitionRangeSensor.getValue() < 1700) {
        		intakeState = AcquisitionIntakeStates.OFF;
        		closeAcq();
        	} else {
				acquisitionLeft.set(Constants.ACQUISITION_DEFAULT_INTAKE_SPEED);
				acquisitionRight.set(-Constants.ACQUISITION_DEFAULT_INTAKE_SPEED);
        	}
			break;
        case REVERSE:
        	System.out.println("I'm reversing!!");
	    	acquisitionLeft.set(-Constants.ACQUISITION_DEFAULT_REVERSE_SPEED);
	    	acquisitionRight.set(Constants.ACQUISITION_DEFAULT_REVERSE_SPEED);
	    	break;
        }
        
        //-890 down, -197 up
        //System.out.println(operatorGamepad.getRawAxis(5));
        if (Math.abs(operatorGamepad.getRawAxis(1)) > 0.1) {
        	isManuallyOperated = true;
        }
        
        /*if (acquisitionPivot.getSensorCollection().isFwdLimitSwitchClosed()) {
        	acquisitionPivot.setSelectedSensorPosition(0, Constants.ACQUISITION_PIVOT_DEFAULT_POS, 0);
        }*/
        
       /* if (operatorGamepad.getPOV() == 90) {
        	climbPivot();
        } else if (operatorGamepad.getPOV() == 270) {
        	resetPivot();
        }*/
        
        if (!isManuallyOperated) {
		    switch(pivotState) {
		    case RESET:
		    	acquisitionPivot.set(ControlMode.Position, Constants.ACQUISITION_PIVOT_RESET_POS);
		    	desiredPosition = Constants.ACQUISITION_PIVOT_RESET_POS;
		    	break;
		    case DEFAULT:
		    	acquisitionPivot.set(ControlMode.Position, Constants.ACQUISITION_PIVOT_DEFAULT_POS);
		    	desiredPosition = Constants.ACQUISITION_PIVOT_DEFAULT_POS;
		    	break;
		    case CLIMB:
		    	acquisitionPivot.set(ControlMode.Position, Constants.ACQUISITION_PIVOT_CLIMB_POS);
		    	desiredPosition = Constants.ACQUISITION_PIVOT_CLIMB_POS;
		    }
        } else {
        	//System.out.prin
        	if (-operatorGamepad.getRawAxis(1) > 0.1) acquisitionPivot.set(ControlMode.PercentOutput, -operatorGamepad.getRawAxis(1)); //desiredPosition += 20;
        	else if (-operatorGamepad.getRawAxis(1) < -0.1) acquisitionPivot.set(ControlMode.PercentOutput, -operatorGamepad.getRawAxis(1)); //desiredPosition -= 20;
        	else acquisitionPivot.set(ControlMode.PercentOutput, 0);
        	//if (desiredPosition > Constants.ACQUISITION_PIVOT_DEFAULT_TICKS) desiredPosition = Constants.ACQUISITION_PIVOT_DEFAULT_TICKS;
        	
        	//acquisitionPivot.set(ControlMode.Position, desiredPosition);
        }
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void reverse() {
    	intakeState = AcquisitionIntakeStates.REVERSE;
    }
    
    public void intake() {
    	intakeState = AcquisitionIntakeStates.INTAKE;
    }
    
    public void off() {
    	intakeState = AcquisitionIntakeStates.OFF;
    }
    
    public void resetPivot() {
    	pivotState = AcquisitionPivotStates.RESET;
    	isManuallyOperated = false;
    }
    
    public void defaultPivot() {
    	pivotState = AcquisitionPivotStates.DEFAULT;
    	isManuallyOperated = false;
    }
    
    public void climbPivot() {
    	pivotState = AcquisitionPivotStates.CLIMB;
    	isManuallyOperated = false;
    }
    
    public void closeAcq() {
    	acqOpen = false;
    	acquisitionSolenoid.set(acqOpen);
    }
    
    public void openAcq() {
    	acqOpen = true;
    	acquisitionSolenoid.set(acqOpen);
    }
    
    public boolean isOpen() {
    	return acquisitionSolenoid.get();
    }
}

