// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3173.IgKnighters2018.subsystems;
import edu.wpi. first.wpilibj.PWMTalonSRX;

import org.usfirst.frc3173.IgKnighters2018.Robot;
import org.usfirst.frc3173.IgKnighters2018.RobotMap;
import org.usfirst.frc3173.IgKnighters2018.commands.*;
import org.usfirst.frc3173.IgKnighters2018.utilities.Constants;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix. motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Solenoid;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 * @JohnMarangola @JonathanAbbott
 */
public class Elevator extends Subsystem {
	public static enum ElevatorStates {
		FLOOR, VAULT, SWITCH, SCALE
	}
	
    private final WPI_TalonSRX elevatorMotor = RobotMap.elevatorMotor;
    private final WPI_TalonSRX elevatorMotorSlave = RobotMap.elevatorMotorSlave;
    private final Solenoid elevatorShifter = RobotMap.elevatorShifter;
    private boolean shifterShifterState = false;
    private boolean isManuallyOperated;
    private ElevatorStates state;
    private int targetPos;
    private Joystick operatorGamepad;
    
    private boolean buttonReset;
  //  private final DigitalInput switch_Top = RobotMap.elevatorTop;
 //   private final DigitalInput switch_Bottom = RobotMap.elevatorBottom;

    public Elevator() {
    	/*
    	 * So, we want our motors to run to a target position dictated by our encoders.
    	 * To do that we probably have to change the mode.
    	 */
    	elevatorMotorSlave.follow(elevatorMotor);
    	elevatorMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 0);
    	elevatorMotor.configOpenloopRamp(0.5, 0);
    	elevatorMotor.setSensorPhase(true); //true for comp, false for practice
    	
    	elevatorMotor.config_kF(0, 0.2, 0);
    	elevatorMotor.config_kP(0, 0.3, 0);
    	elevatorMotor.config_kI(0, 0, 0);
    	elevatorMotor.config_kD(0, 0, 0);

    	state = ElevatorStates.FLOOR;
    	isManuallyOperated = true;
    	buttonReset = false;
    	
    	//System.out.println("Verifying elevator control mode...");
    	//System.out.println("Elevator Control Mode: " + elevatorMotor.getControlMode());

    	targetPos = 0;
    }
    
    @Override
    public void initDefaultCommand() {
    	
    }

    @Override
    public void periodic() {
    	operatorGamepad = Robot.oi.operatorGamepad;
        // Put code here to be run every loop
    	//SmartDashboard.putBoolean("[Elevator] elevatorShifterVal", elevatorShifter.get());
    	//SmartDashboard.putNumber("[Elevator] targetPosition", targetPos);
    	//SmartDashboard.putNumber("[Elevator] elevatorEncoder", elevatorMotor.getSelectedSensorPosition(0));
    	//elevatorMotor.set(ControlMode.Position, Robot.oi.getGamepad().getRawAxis(0) * 500);
    	//SmartDashboard.putBoolean("[Elevator] topLimitSwitch", elevatorMotor.getSensorCollection().isFwdLimitSwitchClosed());
    	//SmartDashboard.putBoolean("[Elevator] bottomLimitSwitch", elevatorMotor.getSensorCollection().isRevLimitSwitchClosed());
    	//SmartDashboard.putString("[Elevator] elevatorOperationState", state.toString());
    	//System.out.println("back: " + operatorGamepad.getRawButton(Robot.oi.BUTTON_BACK) + "; start: " + operatorGamepad.getRawButton(Robot.oi.BUTTON_START));
    	//SmartDashboard.putNumber("[Elevator] Target Position (In Percent)", Math.round(100 * targetPos / (double)Constants.ELEVATOR_SCALE_HEIGHT_TICKS) / 100.0);
    	
    	if (elevatorMotor.getSelectedSensorPosition(0) > Constants.ELEVATOR_SWITCH_HEIGHT_TICKS - 500) Robot.drives.setLowSpeed();
    	else Robot.drives.setHighSpeed();
    	
    	if (!buttonReset && operatorGamepad.getRawButton(Robot.oi.BUTTON_BACK) && operatorGamepad.getRawButton(Robot.oi.BUTTON_START)) {
    		Robot.climber.lockClimber();
    		System.out.println("[INFO] LOCKING CLIMBER!!");
    		buttonReset = true;
    	} else if (!operatorGamepad.getRawButton(Robot.oi.BUTTON_BACK) && !operatorGamepad.getRawButton(Robot.oi.BUTTON_START)){
    		buttonReset = false;
    	}
    	
    	//if (operatorGamepad.getPOV() == 0 || operatorGamepad.getPOV() == 180) isManuallyOperated = true;
    	if (Math.abs(operatorGamepad.getRawAxis(5)) > 0.1) {
    		isManuallyOperated = true;
    	}
    	
    	if (!elevatorMotor.getSensorCollection().isRevLimitSwitchClosed()) elevatorMotor.setSelectedSensorPosition(0, 0, 0);
    	
    	if (!isManuallyOperated) {
    		switch (state) {
    		case FLOOR:
        		elevatorMotor.set(ControlMode.PercentOutput, -1);
        		targetPos = 0;
        		break;
    		case VAULT:
    			elevatorMotor.set(ControlMode.Position, Constants.ELEVATOR_VAULT_HEIGHT_TICKS);
    			targetPos = Constants.ELEVATOR_VAULT_HEIGHT_TICKS;
    			break;
        	case SWITCH:
        		elevatorMotor.set(ControlMode.Position, Constants.ELEVATOR_SWITCH_HEIGHT_TICKS);
        		targetPos = Constants.ELEVATOR_SWITCH_HEIGHT_TICKS;
        		break;
        	case SCALE:
        		elevatorMotor.set(ControlMode.Position, Constants.ELEVATOR_SCALE_HEIGHT_TICKS);
        		targetPos = Constants.ELEVATOR_SCALE_HEIGHT_TICKS;
        		break;
        	}
    	} else {
    		if (-operatorGamepad.getRawAxis(5) > 0.1) targetPos += 200 * ((-operatorGamepad.getRawAxis(5) - 0.1) / 0.9);
        	else if (-operatorGamepad.getRawAxis(5) < -0.1) targetPos -= 200 * ((-operatorGamepad.getRawAxis(5) + 0.1) / -0.9);
    		
    		elevatorMotor.set(ControlMode.Position, targetPos);
    	}
    	
    }
    
    //Subsystem specific methods
    public int getPosition(){
    	return targetPos;
    }
    
    public void goUpPosition() {
    	if (state == ElevatorStates.FLOOR) state = ElevatorStates.VAULT;
    	else if (state == ElevatorStates.VAULT) state = ElevatorStates.SWITCH;
    	else if (state == ElevatorStates.SWITCH) state = ElevatorStates.SCALE;
    	isManuallyOperated = false;
    }
    
    public void goDownPosition() {
    	if (state == ElevatorStates.SCALE) state = ElevatorStates.SWITCH;
    	else if (state == ElevatorStates.SWITCH) state = ElevatorStates.VAULT;
    	else if (state == ElevatorStates.VAULT) state = ElevatorStates.FLOOR;
    	isManuallyOperated = false;
    }
    
    public void scaleState() {
    	state = ElevatorStates.SCALE;
    	isManuallyOperated = false;
    }
    
    public void switchState() {
    	state = ElevatorStates.SWITCH;
    	isManuallyOperated = false;
    }
    
    public void vaultState() {
    	state = ElevatorStates.VAULT;
    	isManuallyOperated = false;
    }
    
    public void floorState() {
    	state = ElevatorStates.FLOOR;
    	isManuallyOperated = false;
    }
    
    public void toggleShifter()
    {
    	if (getShifterState() == false) shifterShifterState = true;
    	else shifterShifterState = false;
    	
    	elevatorShifter.set(shifterShifterState);
    		
    }
    
    public boolean getShifterState()
    {
    	return elevatorShifter.get();
    }
    
    public boolean isAtScale() {
    	return Math.abs(Constants.ELEVATOR_SCALE_HEIGHT_TICKS - elevatorMotor.getSelectedSensorPosition(0)) < 10;
    }
    
    public boolean isAtFloor() {
		return Math.abs(Constants.ELEVATOR_FLOOR_HEIGHT_TICKS - elevatorMotor.getSelectedSensorPosition(0)) < 10;
    }
}

