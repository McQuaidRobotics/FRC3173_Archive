// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3173.IgKnighters2018.subsystems;

import org.usfirst.frc3173.IgKnighters2018.Robot;
import org.usfirst.frc3173.IgKnighters2018.RobotMap;
import org.usfirst.frc3173.IgKnighters2018.commands.*;
import org.usfirst.frc3173.IgKnighters2018.utilities.*;

import edu.wpi.first.wpilibj.command.Subsystem;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Sendable;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 * @JonathanAbbott @MichaelBowen @JohnMarangola 
 */
public class Drives extends Subsystem {
	private final  DifferentialDrive drivesController = RobotMap.drivesController;
    private final WPI_TalonSRX drivesLeftCenter = RobotMap.drivesLeftMaster;
    private final WPI_TalonSRX drivesRightCenter = RobotMap.drivesRightMaster;
    private final WPI_TalonSRX drivesLeftFront = RobotMap.drivesLeftFront;
    private final WPI_TalonSRX drivesRightFront = RobotMap.drivesRightFront;
    private final WPI_TalonSRX drivesLeftBack = RobotMap.drivesLeftBack;
    private final WPI_TalonSRX drivesRightBack = RobotMap.drivesRightBack;
    private final Solenoid drivesShifter = RobotMap.drivesShifter;
    private final AHRS imu = RobotMap.imu;
    
    public static enum OperativeState {
		TANK_DRIVE, ARCADE_DRIVE
	};
    
	private Joystick driverGamepad;
	private SendableChooser<Boolean> autoGearShift = new SendableChooser<>();
	private MovingAverage currentAverage;
    private boolean shifterState = false; //low gear
    private OperativeState opState;
    private float speed;
    private float current;
    private float voltage;
    
    private int leftError, rightError;
    
    public Drives() {
    	//autoGearShift.addDefault("Auto", new Boolean(true));
    	//autoGearShift.addObject("Manual", new Boolean(false));
    	//SmartDashboard.putData("Shift Gear", autoGearShift);
    	
    	//configure master motors with a ramp to full speed over one second
    	leftError = 0; rightError = 0;
    	currentAverage = new MovingAverage();
    	speed = Constants.DRIVES_HIGH_SPEED;
    	drivesLeftCenter.configOpenloopRamp(Constants.DRIVES_DEFAULT_RAMP_TIME, 0);
    	drivesRightCenter.configOpenloopRamp(Constants.DRIVES_DEFAULT_RAMP_TIME, 0);
    	
    	//configure slave motors, so we don't have to program 3x
    	drivesLeftFront.follow(drivesLeftCenter);
    	drivesLeftBack.follow(drivesLeftCenter);
    	drivesRightFront.follow(drivesRightCenter);
    	drivesRightBack.follow(drivesRightCenter);
    	
    	//configure PID
    	drivesLeftCenter.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 0);
    	drivesLeftCenter.setSensorPhase(false);
    	drivesLeftCenter.config_kF(0, Constants.DRIVES_F_VALUE, 0);
    	drivesLeftCenter.config_kP(0, Constants.DRIVES_P_VALUE, 0);
    	drivesLeftCenter.config_kI(0, Constants.DRIVES_I_VALUE, 0);
    	drivesLeftCenter.config_kD(0, Constants.DRIVES_D_VALUE, 0);
    	
    	drivesRightCenter.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 0);
    	drivesRightCenter.setSensorPhase(false);
    	drivesRightCenter.config_kF(0, Constants.DRIVES_F_VALUE, 0);
    	drivesRightCenter.config_kP(0, Constants.DRIVES_P_VALUE, 0);
    	drivesRightCenter.config_kI(0, Constants.DRIVES_I_VALUE, 0);
    	drivesRightCenter.config_kD(0, Constants.DRIVES_D_VALUE, 0);
    	
    	//TODO: this comment
    	opState = Constants.DEFAULT_OPERATIVE_STATE;
    	shiftLowGear();
    }
    
    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new TeleOpManualDrive());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    	//driverGamepad = Robot.oi.driverGamepad;
    	//SmartDashboard.putNumber("[Drives] leftMotorSpeed", drivesLeftCenter.get());
    	//SmartDashboard.putNumber("[Drives] rightMotorSpeed", drivesRightCenter.get());
    	//.putNumber("[Drives] leftMotorEncoder", drivesLeftCenter.getSelectedSensorPosition(0));
    	//SmartDashboard.putNumber("[Drives] rightMotorEncoder", drivesRightCenter.getSelectedSensorPosition(0));
    	//SmartDashboard.putBoolean("[Drives] gearShifterVal", drivesShifter.get());
    	//SmartDashboard.putString("[Drives] operationState", getDriveOpState().toString());
    	//SmartDashboard.putNumber("imu angle", imu.getAngle());
    	//SmartDashboard.putNumber("IMU Angle", imu.getCompassHeading());
    	/*updateCurrentAndVoltage();
    	currentAverage.update(current);
    	
    	//SmartDashboard.putNumber("[Drives] Average Current", currentAverage.getAverage());
    	//SmartDashboard.putNumber("[Drives] Average Delta Current", currentAverage.getDelta());
    	
    	if (!Robot.getInstance().isAutonomous && autoGearShift.getSelected().booleanValue()) {
    		if (Math.abs(currentAverage.getDelta()) > 0.3 || current >= 100) {
        		shiftLowGear();
        	} else if (Math.abs(currentAverage.getDelta()) < 0.3) {
        		shiftHighGear();
        	}
    	}*/
    }

    //setter methods
    public void shiftDrives()
    {
    	if (getShifterState() == false) shifterState = true;
    	else shifterState = false;
    	
    	drivesShifter.set(shifterState);
    }
    
    public void shiftLowGear() {
    	shifterState = false;
    	drivesShifter.set(shifterState);
    }
    
    public void shiftHighGear() {
    	shifterState = true; //true
    	drivesShifter.set(shifterState);
    }
    
    public void setLowSpeed()
    {
    	speed = Constants.DRIVES_LOW_SPEED;
    }
    
    public void setHighSpeed()
    {
    	speed = Constants.DRIVES_HIGH_SPEED;
    }
    
    public void setArcadeOp()
    {
    	opState = OperativeState.ARCADE_DRIVE;
    }
    
    public void setTankOp() 
    {
    	opState = OperativeState.TANK_DRIVE;
    }
    
    public void stop()
    {
    	drivesController.stopMotor();
    }
    
    public void updateCurrentAndVoltage() {
    	current = 0;
    	voltage = (float)RobotMap.pdp.getVoltage();
    	current += RobotMap.pdp.getCurrent(0);
    	current += RobotMap.pdp.getCurrent(1);
    	current += RobotMap.pdp.getCurrent(2);
    	current += RobotMap.pdp.getCurrent(3);
    	current += RobotMap.pdp.getCurrent(12);
    	current += RobotMap.pdp.getCurrent(13);
    	SmartDashboard.putNumber("Current Draw", current);
    	SmartDashboard.putNumber("Voltage Draw", voltage);
    }
    
    public void updateError(int leftError, int rightError) {
    	this.leftError += leftError;
    	this.rightError += rightError;
    }

    //getter methods
    public double getTotalCurrentDraw() {
    	return current;
    }
    
    public DifferentialDrive getDriveController() {
    	return drivesController;
    }
    
    public OperativeState getDriveOpState() 
    {
    	return opState;
    }
    
    public boolean getShifterState()
    {
    	return drivesShifter.get();
    }
    
    public float getSpeed() 
    {
    	return speed;
    }
    
    public AHRS getIMU() {
    	return imu;
    }
    
    public int[] getLeftRightError() {
    	return new int[] { leftError, rightError };
    }
}

