// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3173.IgKnighters2018;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc3173.IgKnighters2018.commandgroups.AutonomousFirstStation;
import org.usfirst.frc3173.IgKnighters2018.commandgroups.AutonomousPath;
import org.usfirst.frc3173.IgKnighters2018.commandgroups.AutonomousSwitch;
import org.usfirst.frc3173.IgKnighters2018.commandgroups.AutonomousGoStraight;
import org.usfirst.frc3173.IgKnighters2018.commands.*;
import org.usfirst.frc3173.IgKnighters2018.deprecated.PathBuilder;
import org.usfirst.frc3173.IgKnighters2018.subsystems.*;
import org.usfirst.frc3173.IgKnighters2018.utilities.Constants;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in the
 * project.
 * 
 * @TEAM
 * 
 * 		Welcome to my domain, padiwans...
 * @author Jonathan
 */
public class Robot extends TimedRobot {

	Command autonomousManager;
	SendableChooser<String> positionChooser = new SendableChooser<>();
	SendableChooser<String> autonomousChooser = new SendableChooser<>();

	public static OI oi;
	public static Drives drives;
	public static Elevator elevator;
	public static Acquisition acquisition;
	public static Climber climber;
	// public static Vision vision;
	public static Robot instance;
	public static String gameSpecificData;

	public boolean isAutonomous;

	/**
	 * This function is run when the robot is first started up and should be used
	 * for any initialization code.
	 */
	@Override
	public void robotInit() {
		RobotMap.init();
		drives = new Drives();
		elevator = new Elevator();
		acquisition = new Acquisition();
		climber = new Climber();
		// vision = new Vision();
		instance = this;
		isAutonomous = false;
		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to be
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.
		oi = new OI();

		// select driver station position
		positionChooser.addDefault("DS One", Constants.DRIVERSTATION_ONE_STRING);
		positionChooser.addObject("DS Two", Constants.DRIVERSTATION_TWO_STRING);
		positionChooser.addObject("DS Three", Constants.DRIVERSTATION_THREE_STRING);

		// select autonomous protocol
		autonomousChooser.addDefault("Auto Pass Line", Constants.AUTONOMOUS_PROTOCOL_PASS_LINE);
		autonomousChooser.addObject("Auto Switch", Constants.AUTONOMOUS_PROTOCOL_SWITCH);
		autonomousChooser.addObject("Auto Scale", Constants.AUTONOMOUS_PROTOCOL_SCALE);

		// populate smart dashboard
		SmartDashboard.putData("Starting Position", positionChooser);
		SmartDashboard.putData("Auto Protocol", autonomousChooser);
		//SmartDashboard.putData("auto go forward", new AutonomousPathfinder());
		SmartDashboard.putData("Forward Rot", new AutonomousDriveEncoder(Constants.LEFT_DRIVES_TICKS_PER_REV, Constants.RIGHT_DRIVES_TICKS_PER_REV));
		// SmartDashboard.putData("Autonomous Turn Right 90", new
		// AutonomousTurnToHeading(90));
	}

	/**
	 * This function is called when the disabled button is hit. You can use it to
	 * reset subsystems before shutting down.
	 */
	@Override
	public void disabledInit() {

	}

	@Override
	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}

	@Override
	public void autonomousInit() {
		isAutonomous = true;
		gameSpecificData = DriverStation.getInstance().getGameSpecificMessage();
		// System.out.println("[AUTO] Game specific data: " + gameSpecificData);
		/*
		 * System.out.
		 * println("[AUTO] Initializing autonomous with selected position: " +
		 * positionChooser.getSelected());
		 * 
		 * PathBuilder pathBuilder = new PathBuilder(gameSpecificData,
		 * positionChooser.getSelected(), autonomousChooser.getSelected());
		 * System.out.println("[AUTO] Initializing autonomous with path: "); for (int
		 * i = 0; i < pathBuilder.getPath().length; i++) { System.out.println(i +
		 * " : " + pathBuilder.getPath()[i].toString()); }0.0kj'
		 * System.out.println("[AUTO] Initializing autonomous with exit angle (" +
		 * pathBuilder.getExitAngle() + ") and exit action (" +
		 * pathBuilder.getExitAction().toString() +")");
		 * 
		 * autonomousManager = new AutonomousPath(pathBuilder.getPath(),
		 * pathBuilder.getExitAngle(), pathBuilder.getExitAction());
		 * autonomousManager.start();
		 */
		/*
		 * if (positionChooser.getSelected() == Constants.DRIVERSTATION_ONE_STRING) {
		 * System.out.
		 * println("[AUTO] Initializing auto for Position One, Driverstation One.");
		 * autonomousManager = new AutonomousFirstStation(gameSpecificData); } else if
		 * (positionChooser.getSelected() == Constants.DRIVERSTATION_THREE_STRING) {
		 * System.out.
		 * println("[AUTO] Initializing auto for Position Three, Driverstation Three.");
		 */
		System.out.println("[AUTO] RUNNING SWITCH WITH POSITION: " + positionChooser.getSelected() + " AND GAME DATA: " + gameSpecificData);
		autonomousManager = new AutonomousSwitch(gameSpecificData, positionChooser.getSelected());//new AutonomousGoStraight(gameSpecificData); //new AutonomousPathfinder(); //new AutonomousThirdStation(gameSpecificData);
		/*
		 * } else { System.out.println("[AUTO] Initializing stall autonomous.");
		 * autonomousManager = new AutonomousStall(); }
		 */
		autonomousManager.start();
	}

	/**
	 * This function is called periodically during autonomous
	 */
	@Override
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}

	@Override
	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		isAutonomous = false;
		if (autonomousManager != null) {
			//// System.out.println("[AUTO] Autonomous still running... Canceling for
			//// teleop...");
			autonomousManager.cancel();
		}
	}

	/**
	 * This function is called periodically during operator control
	 */
	@Override
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
		// SmartDashboard.putNumber("pov", Robot.oi.driverGamepad.getPOV());
	}

	public static Robot getInstance() {
		return instance;
	}
}
