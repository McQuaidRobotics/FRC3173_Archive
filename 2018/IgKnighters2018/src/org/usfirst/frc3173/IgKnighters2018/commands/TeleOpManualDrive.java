// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3173.IgKnighters2018.commands;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

//import org.usfirst.frc3173.COOKIECODE2018.RobotMap;
import org.usfirst.frc3173.IgKnighters2018.Robot;
import org.usfirst.frc3173.IgKnighters2018.RobotMap;
import org.usfirst.frc3173.IgKnighters2018.subsystems.Drives;
import org.usfirst.frc3173.IgKnighters2018.utilities.Constants;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

/**
 *
 */
public class TeleOpManualDrive extends Command {
	
	private static final WPI_TalonSRX leftMaster = RobotMap.drivesLeftMaster;
	private static final WPI_TalonSRX rightMaster = RobotMap.drivesRightMaster;
	
	private boolean shouldTerminate;
	private Joystick driverGamepad;
	
    public TeleOpManualDrive() {
        requires(Robot.drives);
        driverGamepad = Robot.oi.driverGamepad;
        shouldTerminate = false;
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	//System.out.println("[COMMAND] TeleOpManualDrive!");
    	leftMaster.set(ControlMode.PercentOutput, 0);
    	rightMaster.set(ControlMode.PercentOutput, 0);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	if (Robot.drives.getDriveOpState() == Drives.OperativeState.ARCADE_DRIVE) {
    		//gets the values from the joysticks
    		if (driverGamepad.getRawAxis(2) + driverGamepad.getRawAxis(3) > 0.2) {
    			double leftVal = driverGamepad.getRawAxis(2); //Math.round(driverGamepad.getRawAxis(2) * 10) / 10.0;
    			double rightVal = driverGamepad.getRawAxis(3); //Math.round(driverGamepad.getRawAxis(3) * 10) / 10.0;
    			leftMaster.set(leftVal * 0.5);
    			rightMaster.set(rightVal * 0.5);
    		} else {
    			double throttle = (Math.round(driverGamepad.getRawAxis(4) * 100) / 100.0) * Robot.drives.getSpeed(); //(Math.round(driverGamepad.getRawAxis(4) * 10) / 10.0) * Robot.drives.getSpeed();
            	double rotation = -(Math.round(driverGamepad.getRawAxis(1) * 100) / 100.0) * Robot.drives.getSpeed();
            	//takes the values from controller and applies it to the motors
            	Robot.drives.getDriveController().arcadeDrive(throttle, rotation);
    		}
    	} else if (Robot.drives.getDriveOpState() == Drives.OperativeState.TANK_DRIVE) {
    		//tank drive operation
    		double leftSpeed = (Math.round(driverGamepad.getRawAxis(1) * 10) / 10.0) * Robot.drives.getSpeed();
    		double rightSpeed = (Math.round(driverGamepad.getRawAxis(5) * 10) / 10.0) * Robot.drives.getSpeed();
    		Robot.drives.getDriveController().tankDrive(leftSpeed, rightSpeed);
    		//Robot.oi.getGamepad().setRumble(RumbleType.kLeftRumble, 1.0);
            //Robot.oi.getGamepad().setRumble(RumbleType.kRightRumble, 1.0);
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return shouldTerminate;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	shouldTerminate = true;
    }
    
}
