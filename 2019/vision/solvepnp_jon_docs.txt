SolvePnP, other than being a new and improved way to exacerbate my hair loss, is a OpenCV algorithm that attempts to relate the 3-dimensional space to the 2-dimensional space. In taking a picture on our Logitech camera, we can take an object's represented 2-dimensional moments - important points - and determine the object's current pose, given the 3-dimensional "model moments" of when the object is in "anatomical position" towards the camera. The format of these "model moments" is tricky, though, because it blatantly contradicts the format of the "image points" - the aforementioned 2-dimensional current moments of the focused object - which is all due, covertly and overtly, to the difference in coordinate systems. The "model moments" uses the world-coordinate system which, in and of itself, is a way in representing the world in the typical 3-axis format: up to down for decreasing y-values, right to left for decreasing y-values, and whatever for z-values. Notice here how up to down translates to a decreasing y-value - this is the point of contradiction! See, in the "image points," we are constricted to the coordinate system of OpenCV, and by extent typical computer convention, where the top left of the screen, or matrix, is 0,0. So, it is in this very convention that gives rise to the fact that down to up is decreasing y-values! So, when we enter in the matrix of our model moments, we have to relate the points of the object in such a way that points "higher" than others have a positive y-differential; the x-axis for both coordinate systems are the same. However, one must only account for this in the model moments matrix. The image points that are required for the SolvePnP function must be ordered in the same way the indeces are of the model points, but it also takes these points as if one was in the OpenCV coordinate system - where down is positive y-value. This SolvePnP function returns both a rotational matrix and a translational matrix, which are unrelated the euler angles we are all familiar with. In using the Rodrigues function, we can convert our rotational matrix to a rotation vector and, after concatenating it with our translational matrix, turns into a projected matrix which can be decomposed into our familiar euler angles - where yaw is the rotation around y-axis, roll is the rotation around z-axis, and pitch is the rotation around the x-axis. Tada!


this isnt saved