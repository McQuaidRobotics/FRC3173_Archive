// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3173.IgKNIGHTers.commands;
import edu.wpi.first.wpilibj.RobotDrive.MotorType;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;

import org.usfirst.frc3173.IgKNIGHTers.OI;
import org.usfirst.frc3173.IgKNIGHTers.Robot;
import org.usfirst.frc3173.IgKNIGHTers.RobotMap;

import com.ctre.CANTalon;

/**
 * @author JacobLaptop
 */
public class MecunumDrive extends Command {
	private final CANTalon leftMotorTop = RobotMap.drivesLeftMotorTop;
    private final CANTalon rightMotorTop = RobotMap.drivesRightMotorTop;
    private final CANTalon leftMotorBottom = RobotMap.drivesLeftMotorBottom;
    private final CANTalon rightMotorBottom = RobotMap.drivesRightMotorBottom;
    final String defaultAuto = "Default";
	final String customAuto = "My Auto";
	String autoSelected;
	SendableChooser<String> chooser = new SendableChooser<>();
	 public static int kMaxNumberOfMotors=4;
	public static double iniOrienation=0.0;
	

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public MecunumDrive() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    	requires(Robot.drives);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	//Robot.drives.Meca(Robot.oi.mecunumJoystick);
    	double gyroAngle=0.0;
    	double rotation;
    	double xIn;
    	double yIn; 
	 	if (Robot.oi.mecunumJoystick.getTwist()<0){
    		rotation=-Math.pow(Robot.oi.mecunumJoystick.getTwist(),2);
	 	}
	 	else{
	 		rotation=Math.pow(Robot.oi.mecunumJoystick.getTwist(),2);
	 	}
	 	if (Robot.oi.mecunumJoystick.getX()<0){
	 		xIn = -Math.pow(Robot.oi.mecunumJoystick.getX(),2);}
	 	else{
	 		xIn = Math.pow(Robot.oi.mecunumJoystick.getX(),2);
	 	}
	 	if (Robot.oi.mecunumJoystick.getY()<0){
	 		yIn = -Math.pow(Robot.oi.mecunumJoystick.getY(),2);
	 	}
	 	else{
	 		yIn = Math.pow(Robot.oi.mecunumJoystick.getY(),2);
	 	}
	 	double m_maxOutput=1.0;
	    // Negate y for the joystick.
	    yIn = -yIn;
	    // Compenstate for gyro angle.
	    double[] rotated = rotateVector(xIn, yIn, gyroAngle);
	    xIn = rotated[0];
	    yIn = rotated[1];

	    double[] wheelSpeeds = new double[4];
	    wheelSpeeds[MotorType.kFrontLeft.value] = xIn + yIn + rotation;
	    wheelSpeeds[MotorType.kFrontRight.value] = -xIn + yIn - rotation;
	    wheelSpeeds[MotorType.kRearLeft.value] = -xIn + yIn + rotation;
	    wheelSpeeds[MotorType.kRearRight.value] = xIn + yIn - rotation;

	    
	    normalize(wheelSpeeds);
	    leftMotorTop.set(wheelSpeeds[MotorType.kFrontLeft.value] * m_maxOutput);
	    rightMotorTop.set(wheelSpeeds[MotorType.kFrontRight.value] * -m_maxOutput);
	    leftMotorBottom.set(wheelSpeeds[MotorType.kRearLeft.value] * m_maxOutput);
	    rightMotorBottom.set(wheelSpeeds[MotorType.kRearRight.value] * -m_maxOutput);

    }

    protected static double[] rotateVector(double x, double y, double angle) {
	    double cosA = Math.cos(angle * (3.14159 / 180.0));
	    double sinA = Math.sin(angle * (3.14159 / 180.0));
	    double[] out = new double[2];
	    out[0] = x * cosA - y * sinA;
	    out[1] = x * sinA + y * cosA;
	    return out;
	  }
	protected static void normalize(double[] wheelSpeeds) {
	    double maxMagnitude = Math.abs(wheelSpeeds[0]);
	    for (int i = 1; i < kMaxNumberOfMotors; i++) {
	      double temp = Math.abs(wheelSpeeds[i]);
	      if (maxMagnitude < temp) {
	        maxMagnitude = temp;
	      }
	    }
	    if (maxMagnitude > 1.0) {
	      for (int i = 0; i < kMaxNumberOfMotors; i++) {
	        wheelSpeeds[i] = wheelSpeeds[i] / maxMagnitude;
	      }
	    }
	  }
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
