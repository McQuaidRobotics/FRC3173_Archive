// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc3173.IgKnighters2013.commands;

import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.DriverStationLCD;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.WaitCommand;
import org.usfirst.frc3173.IgKnighters2013.Robot;
import org.usfirst.frc3173.IgKnighters2013.RobotMap;

/**
 *
 * @ Thomas Skysword
 */
public class Autonomous extends Command {

	private WaitCommand wait;
	private boolean first = true;

	public Autonomous() {
		// Use requires() here to declare subsystem dependencies
		// eg. requires(chassis);
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}
	// Called just before this Command runs the first time

	protected void initialize() {
		RobotMap.driverstation.println(DriverStationLCD.Line.kUser1, 1, this.toString() + " starting");
		first = true;
		//RobotMap.shooterShooter.setVoltageRampRate(70);
                RobotMap.tilterTilter.setPositionReference(CANJaguar.PositionReference.kPotentiometer);
        
	}
	// Called repeatedly when this Command is scheduled to run

	protected void execute() {
		boolean triggerNotPulled=false;//tracks if auto should manually exits
		if (RobotMap.autoing.get()) {//checks for auto enabled switch multiple times. Any calls to autoing.get() refer to this switch 
			RobotMap.shooterShooter.setVoltageRampRate(5);//May not neccessarily be neccessary, but it is good for you.
			if (first) {//Checks if it is running the first time. if not, it skips
				RobotMap.shooterShooter.changeControlMode(CANJaguar.ControlMode.kCurrent);//current mode sets maximum volts per seccond
				RobotMap.shooterShooter.setPID(1, .1, .1);//see electrical
				RobotMap.shooterShooter.enableControl();
				RobotMap.shooterShooter.setX(-60);//negative because shooter is wired backwards. 60 volts for 1.5 secconds
				Timer.delay(1.5);
				RobotMap.shooterShooter.setX(-40);//40 volts for 5 and a half secconds
				//Timer.delay(1);
				//Robot.shooter.setSpeed(.5);
				//RobotMap.driverstation.println(DriverStationLCD.Line.kUser2, 1, "" + RobotMap.shooterShooter.getOutputCurrent());
				//RobotMap.driverstation.updateLCD();
				Timer.delay(.15);
				//Robot.shooter.setSpeed(.75);
				//RobotMap.driverstation.println(DriverStationLCD.Line.kUser2, 1, "" + RobotMap.shooterShooter.getOutputCurrent());
				//RobotMap.driverstation.updateLCD();
				Timer.delay(.1);
				//Robot.shooter.setSpeed(.80);
				//RobotMap.driverstation.println(DriverStationLCD.Line.kUser2, 1, "" + RobotMap.shooterShooter.getOutputCurrent());
				//RobotMap.driverstation.updateLCD();
				Timer.delay(5.25);//5.75);
                                RobotMap.shooterShooter.changeControlMode(CANJaguar.ControlMode.kSpeed);//speed mode sets RPM
                                RobotMap.shooterShooter.setPID(10,.001 ,.001 );
                                RobotMap.shooterShooter.setSpeedReference(CANJaguar.SpeedReference.kEncoder);
                                RobotMap.shooterShooter.configEncoderCodesPerRev(1);
                                RobotMap.shooterShooter.enableControl(0.0);
                                System.out.println("Speed Mode enabled");
                                RobotMap.shooterShooter.setX(-2500);//2600 RPM for autonomous to work. May lower slightly in the future
			} else {
				Timer.delay(.5);
			}
		}
		if (RobotMap.autoing.get()) {
			if (first) {
                            //loops until tilter reaches specified Hight
				while ((RobotMap.tilterTilter.getPosition()>.08)&&RobotMap.tilterTilter.getReverseLimitOK() && (triggerNotPulled=!(Robot.oi.getLeftJoystick().getRawButton(1)))) {
					//RobotMap.compressor.start();
					RobotMap.driverstation.updateLCD();
					//Robot.shooter.setSpeed(.85);
					Robot.Tilter.setAngle(-1);//tilter is wired backwards as well
					RobotMap.driverstation.println(DriverStationLCD.Line.kUser2, 1, "Looping Angle :" + RobotMap.shooterShooter.getOutputCurrent());
                                        System.out.println((RobotMap.tilterTilter.getPosition()>.075) +" ; "+RobotMap.tilterTilter.getReverseLimitOK());
				}
                                        //Timer.delay(7);
				//Robot.Tilter.setAngle(0);
				RobotMap.driverstation.println(DriverStationLCD.Line.kUser2, 1, "Looping Finished");
			}
			//Robot.shooter.setSpeed(.95);
			//Robot.shooter.fireManual(true);
			RobotMap.driverstation.updateLCD();
			if (first && triggerNotPulled) {
				Timer.delay(.5);
			}
		}
		if (RobotMap.autoing.get()) {
			RobotMap.compressor.start();//begins to shoot frisbees one every .25 seconds until auto exits.
			if (triggerNotPulled) { // Don't shoot if the triggerNotPulled was pulled
				/*wait = new WaitCommand(5);*/
				Robot.shooter.fireManual(true);
				Timer.delay(.25);
				//wait = new WaitCommand(.5);
				Robot.shooter.fireManual(false);
				Timer.delay(.5);
				//wait = new WaitCommand(2);
				Robot.shooter.fireManual(true);
				Timer.delay(.25);
				//wait = new WaitCommand(.5);
				Robot.shooter.fireManual(false);
				Timer.delay(.5); // Changed to delay third shot
				//wait = new WaitCommand(2);
				Robot.shooter.fireManual(true);
				Timer.delay(.25);
				//wait = new WaitCommand(.5);
				Robot.shooter.fireManual(false);
				Timer.delay(.25);
				//wait = new WaitCommand(2);
				Robot.shooter.fireManual(true);
				Timer.delay(.25);
				//wait = new WaitCommand(.5);
				Robot.shooter.fireManual(false);//*/
			}
			first = false;
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		if (Robot.oi.getLeftJoystick().getRawButton(1)) {//refers to the trigger
			return true;
		} else {
			return false;
		}
	}
	// Called once after isFinished returns true

	protected void end() {
		RobotMap.shooterShooter.disableControl();
		RobotMap.shooterShooter.changeControlMode(CANJaguar.ControlMode.kPercentVbus);
		Robot.Tilter.setAngle(0);
	}
	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run

	protected void interrupted() {
		end();
	}
}
