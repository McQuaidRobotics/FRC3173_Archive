// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc3173.IgKnighters2013.subsystems;
import org.usfirst.frc3173.IgKnighters2013.RobotMap;
import org.usfirst.frc3173.IgKnighters2013.commands.*;
import edu.wpi.first.wpilibj.*;
/* DO NOT CHANGE THIS COMMENT!
 * It's needed so the RobotBuilder doesn't put the import back in
import edu.wpi.first.wpilibj.can.*;
*/
import org.usfirst.frc3173.IgKnighters2013.utilities.CANJaguar;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc3173.IgKnighters2013.Robot;
/**
 *@author Cosmo Viola
 * 
 */
public class Drives extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    CANJaguar leftFront = RobotMap.drivesLeftFront;
    CANJaguar rightFront = RobotMap.drivesRightFront;
    CANJaguar leftRear = RobotMap.drivesLeftRear;
    CANJaguar rightRear = RobotMap.drivesRightRear;
    //I2C compass = RobotMap.compass;
    //Gyro gyro1 = RobotMap.driveGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new DriveWithJoysticks());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    /**
     * Code used from previous years, See 2011 for full documentation.
     * @param x double
     * @param y double
     * @param rotation double
     * @param speed multiplier from 0 - 1. Percentage in decimal form
     * 
     */
	public void mecanumDrive(double x, double y, double rotation, double speed) {

		
                    leftFront.setX(speed*(y + rotation + x));
                    rightFront.setX(speed*(-(y - rotation - x)));
                    leftRear.setX(speed*(y + rotation - x));
                    rightRear.setX(speed*(-(y - rotation + x)));
               /* }
                else if(Robot.oi.leftJoystick.getRawButton(5) && !(Robot.oi.leftJoystick.getRawButton(4))){
                    //60% speed
                    leftFront.setX(.6*(y + rotation + x));
                    rightFront.setX(.6*(-(y - rotation - x)));
                    leftRear.setX(.6*(y + rotation - x));
                    rightRear.setX(.6*(-(y - rotation + x)));
                }*/
                //System.out.println("Begin:");
                //comp = compass.addressOnly();
                //System.out.println(comp);
                //System.out.println(RobotMap.accelerometer.getAccelerations());
	}
        public double getRawVector(double x,double y){
            return Math.sqrt((x*x)+(y*y));
        }
         /**
          * see mecanumDrive, requires a gyro to work.
          * @param x
          * @param y
          * @param rotation
          * @param gyro
          * @param speed 
          */
        public void mecanumDriveAbsolute(double x, double y, double rotation, double gyro, double speed) {
            gyro = gyro % 360; // Standardizes angle measurement to be out of 360

            double[] newAxes = rotateVector(x, y, gyro);

            x = newAxes[0];
            y = newAxes[1];

            // Calculates the required motorspeed for each wheel
            //if(!(Robot.oi.leftJoystick.getRawButton(4)&&Robot.oi.leftJoystick.getRawButton(5))){
                    leftFront.setX(y + rotation + x);
                    rightFront.setX(-(y - rotation - x));
                    leftRear.setX(y + rotation - x);
                    rightRear.setX(-(y - rotation + x));
                /*}
                else if(Robot.oi.leftJoystick.getRawButton(4) && !(Robot.oi.leftJoystick.getRawButton(5))){
                    //30% speed
                    leftFront.setX(.3*(y + rotation + x));
                    rightFront.setX(.3*(-(y - rotation - x)));
                    leftRear.setX(.3*(y + rotation - x));
                    rightRear.setX(.3*(-(y - rotation + x)));
                }
                else if(Robot.oi.leftJoystick.getRawButton(5) && !(Robot.oi.leftJoystick.getRawButton(4))){
                    //60% speed
                    leftFront.setX(.6*(y + rotation + x));
                    rightFront.setX(.6*(-(y - rotation - x)));
                    leftRear.setX(.6*(y + rotation - x));
                    rightRear.setX(.6*(-(y - rotation + x)));
                }*/
        }
        // Sets the calculated motorspeed for each wheel
    
        public double[] rotateVector(double x, double y, double angle) {
            double cosA = Math.cos(angle * (Math.PI / 180.0));
            double sinA = Math.sin(angle * (Math.PI / 180.0));
            double out[] = new double[2]; //        x,y
            out[0] = -x * cosA + y * sinA;//out[0] [-|-]
            out[1] = x * sinA + y * cosA;// out[1] [+|-]
            return out;
    }
}
