// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3173.IgKnighters2014.subsystems;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import org.usfirst.frc3173.IgKnighters2014.RobotMap;
import org.usfirst.frc3173.IgKnighters2014.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc3173.IgKnighters2014.Robot;
import org.usfirst.frc3173.IgKnighters2014.utilities.CANJaguar;
/**
 *
 */
public class Shooter extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    CANJaguar shooterPinion = RobotMap.shooterShooterPinion;
    DoubleSolenoid latchPneumatic = RobotMap.shooterLatchPneumatic;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static final int STATEMACHINE_RUN_DELAY = 100;
    
    public static final int STATE_SHOOTING = 0;
    public static final int STATE_PRIMING  = 1;
    public static final int STATE_RESETTING = 2;
    public static final int STATE_FULLRESET = 3;
    public static final int STATE_FIREABLE = 4;
    public static final int STATE_PASS_PRIMING = 5;
    public static final int STATE_PASS_SHOOTING = 6;
    public static final double GOAL_HEIGHT=6.0+10.75/12.0;
    public String rackstatus="front";
    
    private static final double[] motorSpeed = {0,.8,-.8,0,0,1,-1}; //Speeds for shooting, priming, resetting, full reset, and fireable
    private static final String[] stateArray = {"Shooting", "Priming", "Resetting", "Fullly Reset", "Fireable","Pass Priming","Pass Shooting"}; 
    
    private int state = STATE_FIREABLE;
    private long start_time;
    
   public void runStateMachine(){
        if(state==STATE_PRIMING&&!(shooterPinion.getForwardLimitOK())){
            setState(STATE_RESETTING); //if finished priming, set motor speed to move pushy-thing
        }
        
        if(state==STATE_RESETTING&&!(shooterPinion.getReverseLimitOK())){
            setState(STATE_FULLRESET); //detects if pushy thing is all the way to the front and changes state to relfect this
        }
        
        if(state==STATE_FULLRESET&&!(shooterPinion.getReverseLimitOK())){
            setState(STATE_FIREABLE); //checks if pushy thing is at front to be certain it is safe to fire
        }
        
        if(state==STATE_PASS_PRIMING&&!(shooterPinion.getForwardLimitOK())){
            setState(STATE_PASS_SHOOTING);
        }
        shooterPinion.setX(motorSpeed[state]);
        
        SmartDashboard.putBoolean("Shooter Forward Limit Hit ", !(Robot.shooter.shooterPinion.getForwardLimitOK()));
        SmartDashboard.putBoolean("Shooter Reverse Limit Hit ", !(Robot.shooter.shooterPinion.getReverseLimitOK()));
        SmartDashboard.putString("State: ", stateArray[state]);
        if(Robot.shooter.shooterPinion.getForwardLimitOK()&&Robot.shooter.shooterPinion.getReverseLimitOK()){
            rackstatus="In travel";
        } else {
            if(Robot.shooter.shooterPinion.getForwardLimitOK()&&!Robot.shooter.shooterPinion.getReverseLimitOK()){
                rackstatus="front";
            } else {
                if(!Robot.shooter.shooterPinion.getForwardLimitOK()&&Robot.shooter.shooterPinion.getReverseLimitOK()){
                    rackstatus="rear";
                }
            }
        }
        SmartDashboard.putString("Where rack is: ", rackstatus);
   }
       
    protected void setState(int new_state){
        state=new_state;
        if (state == STATE_SHOOTING&&!(shooterPinion.getReverseLimitOK())) {
            start_time = System.currentTimeMillis();
        }
        if (state == STATE_PRIMING) {
            Robot.shooter.latchPneumatic.set(DoubleSolenoid.Value.kOff);
        }
        if(state==STATE_SHOOTING || state==STATE_PASS_SHOOTING){
            Robot.shooter.latchPneumatic.set(DoubleSolenoid.Value.kForward);
        }
    }
    
    public void shoot(){
        if(state==STATE_FIREABLE&&Robot.acquisition.ballDetected(true)&&(!(shooterPinion.getReverseLimitOK()))){//checks limit, state, and if ball is in claw. may be removed for testing purposes
            setState(STATE_SHOOTING); //makes certain that pushy thing is forward at the moment and if the robot has been declared fireable, then shoots
        }
    }
    public void prime() {
        if (state == STATE_SHOOTING) {
            setState(STATE_PRIMING);
        }
        if(state==STATE_PASS_SHOOTING&&!(shooterPinion.getReverseLimitOK())){
            setState(STATE_PRIMING);
        }
    }
    public void passShoot(){
        if(state==STATE_FIREABLE){
            setState(STATE_PASS_PRIMING);
        }
    }
    
    public int getState(){
        return state;
    }
    public void shooterPrep(){
        setState(STATE_PRIMING);
        System.out.println("Huzzah");
    }
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
}
